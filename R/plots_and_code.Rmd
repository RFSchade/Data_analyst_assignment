---
title: "Plotting Parameters"
author: "Rebecca Folmer Schade"
date: "2023-04-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r, include=FALSE}
# Loading packages
pacman::p_load(pacman, tidyverse, plyr, DT)

```

## Load data

```{r, results='hide', message=FALSE, warning=FALSE}
filepath = file.path("..", "output", "model_data.csv")
tbl <- read_csv(filepath)

```

The data loaded from the 'output' folder is generated by running the 
data_extraction.py script found in the 'python' folder.

## Clean data

As can be seen in the table below, there are no NAs in the _id_, _template-key_, 
or _date_ columns. The _weight_ column has a lot of NAs, and the four other 
parameters has the exact same number of NAs.

```{r, echo=FALSE}
# Create table of NAs 
na_tbl <- colSums(is.na(tbl)) %>% as.list() %>% as_tibble()

# Change colname for id 
colnames(na_tbl)[1] <- "id"

# Add descriptive columns
na_tbl <- na_tbl %>% mutate(desc="no. of NAs") %>% select(desc, everything())

# Display table 
knitr::kable(na_tbl, caption = "NAs in data")

```

The _abcd_ columns have the same number of NAs. I filtered out all the NAs in 
the _a_ column, and as can be seen below, it seems like the _abcd_ columns have 
the 23 NAs in common - though the _weight_ columns doesn't.   

```{r, echo=FALSE}
# Filtr NAs in a column
a_na <- tbl %>% filter(is.na(a))

# Create table of NAs
a_na_tbl <- colSums(is.na(a_na[4:9])) %>% as.list() %>% as_tibble()

# Add descriptive columns
a_na_tbl <- a_na_tbl %>% mutate(desc="no. of NAs") %>% select(desc, everything())

# Display table 
knitr::kable(a_na_tbl, caption = "NAs isolated")

```

Most of these could perhaps be explained by looking the data 
extraction from the JSON files. 
The program is instructed to leave most of the _position_, _abcd_ and _weight_ 
columns blank if the JSON files does not contain the "AssayResults"-key, which 
stores all information extracted to these columns. 
The program is also instructed to leave the _abcd_ blank when "AssayResults" 
has no "FitResult"-key, which contains the information extracted into these.

I tried to check in the files for further clarification, but as I have not 
written the extraction program to add a column for the name of the JSON file, 
it would have been an arduous task. 
I decided to let this be for now.  

I do not think there is much data lost in removing rows with NA in the 
_position_ and _abcd_ column, (one datapaoint) so I decided to remove these 
before visualization. 

```{r}
# Removing NAs 
# As all NAs I wish to remove coincide with the NAs in a, I will just filter that.
tbl_clean <- tbl %>% filter(!is.na(a))

```

## Define functions

#### rm_outliers

This function removes outliers from a single variable using the IQR method. 

```{r}
rm_outliers <- function(tbl, y_var) {
  # Define upper and lower threshold
  lower <- median(tbl[[y_var]], na.rm=TRUE) - (IQR(tbl[[y_var]], na.rm=TRUE)*2)
  upper <- median(tbl[[y_var]], na.rm=TRUE) + (IQR(tbl[[y_var]], na.rm=TRUE)*2)
  
  # Remove outliers
  no_out <- tbl %>% 
    filter(!.data[[y_var]] < lower & !.data[[y_var]] > upper)
  
  return(no_out) 
  
}

```

The function filters out all data points with a value further than two times the 
IQR (Inter Quartile Range) from the median of the variable. 

#### y_limits

This function generates a lower and upper limit to the y axis of a plot 
depending on the variable.  

```{r}
y_limits <- function(tbl, y_var) {
  # min
  minimum <- min(rm_outliers(tbl, y_var)[[y_var]])
  min_y <- round_any(minimum, 0.5, f = floor)
  
  # max
  maximum <- max(rm_outliers(tbl, y_var)[[y_var]])
  max_y <- round_any(maximum, 0.5, f = ceiling)
  
  # put in list
  limits <- c(min_y, max_y)
  
  return(limits)
}

```

The function uses the the rm_outliers() function to remove outliers, gets the 
max and min of a given variables, and returns them in the form of items on a 
short list.
Both min and max are rounded to the nearest 0.5 - min is always rounded down, 
while max is always rounded up. That way the axis is a bit prettier, and we 
avoid losing any data points.  

#### limit_table

This function used the y_limits() function to create a table with the y limits 
of all the variables. This way, this calculation only has to happen once. 

```{r}
limit_table <- function(tbl) {
  lim_tbl <- tibble(y_limits = c("lower", "upper"))
  
  y_vars <- colnames(tbl)[5:9]
  
  for (var in y_vars) {
    lim_tbl[[var]] <- y_limits(tbl, var)
  }
  
  return(lim_tbl)
}

```

#### plot_var

This function creates and saves a scatterplot for a single variable, and limits 
the y axis according to the values provided as "lower" and "upper". 

```{r}
plot_var <- function(df, y_var, lower, upper) {
  
  # Remove outliers
  tbl <- rm_outliers(df, y_var)
  
  # Get mean and sd
  y_mean <- mean(tbl[, y_var, drop = TRUE], na.rm=TRUE)
  y_sd <- sd(tbl[, y_var, drop = TRUE], na.rm=TRUE)
  # Get bounds of sd rectangle
  bounds <- data.frame(xmin = -Inf, 
                       xmax = Inf, 
                       ymin = y_mean - y_sd,
                       ymax = y_mean + y_sd
                       )
  
  # Base plot
  plot <- ggplot(tbl, aes(x = date, y = .data[[y_var]])) + 
    # Sd ribbon
    geom_rect(
      aes(
        xmin = as.Date(xmin, origin = '1970-01-01'),
        xmax = as.Date(xmax, origin = '1970-01-01'),
        ymin = ymin,
        ymax = ymax,
        fill = "#009E73",
        ),
      data = bounds,
      alpha = 0.3,
      inherit.aes = FALSE
      ) +
    # Scattered points
    geom_point(size = 2) + 
    geom_hline(
      aes(
        yintercept = mean(.data[[y_var]], na.rm=TRUE),
        color="#D55E00"
        ), 
      linewidth = 1) + 
    # Legend
    scale_color_manual(values = "#D55E00", labels = "Mean") + 
    scale_fill_manual(values = "#009E73", labels = "Sd") + 
    # Limit y 
    coord_cartesian(ylim=c(lower, upper))
  
  # Get title
  no <- str_extract(df$template_key[1], "\\d+")
  pos <- df$position[1]
  title = str_glue("Template Key {no}\n{pos}")
  
  # Make more readable
  clean_plot <- plot + 
    # Theme
    theme_bw() + 
    # Labels
    labs(title = title, 
         x="Date", 
         y=str_glue("Value for {y_var}"), 
         fill = NULL, color = NULL
         )
  
  # Get outpath
  key = str_replace(df$template_key[1], "-", "_")
  small_pos <- str_extract(df$position[1], "P\\d")
  filename <- str_glue("{key}_{small_pos}_{y_var}.png")
  outpath <- file.path("..", "plots", filename)
  
  # Save 
  ggsave(outpath, clean_plot, width = 7, height = 6)
  
  return(clean_plot)
  
}

```

The plot also has a red line describing the mean of the varaible, and a green 
ribbon showing the range of 1 standard deviation from the mean. 
The colors are taken from this [blog-post](https://mikemol.github.io/technique/colorblind/2018/02/11/color-safe-palette.html),
and the contrast between them should be visible for people with color-blindness. 


## Plot all parameters

At last, the code below plots all the variables. 

```{r, eval=FALSE}
# Get limit table 
lim_tbl <- limit_table(tbl_clean)

# Get list of templates 
templates <- unique(tbl_clean$template_key)

# For each template... 
for (template in templates) {
  # Fitler all other templates out
  template_tbl <- tbl_clean %>% filter(template_key == template)
  
  # Get list positions 
  positions <- unique(template_tbl$position)
  
  # For each position... 
  for (pos in positions) {
    # Filter all other positions out 
    position_tbl <- template_tbl %>% filter(position == pos)
    
    # Get list of variables 
    y_vars <- colnames(position_tbl)[5:9]
    
    # For each variable
    for (var in y_vars) {
      # Get y limits
      y_min <- lim_tbl[[var]][1]
      y_max <- lim_tbl[[var]][2]
      
      # plot variable
      plot_var(position_tbl, var, y_min, y_max)
    }
  } 
}

```



